慢查询优化基本步骤 0.先运行看看是否真的很慢，注意设置 SQL_NO_CACHE

1.where 条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的 where 都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高

2.explain 查看执行计划，是否与 1 预期一致（从锁定记录较少的表开始查询）

3.order by limit 形式的 sql 语句让排序的表优先查

4.了解业务方使用场景

5.加索引时参照建索引的几大原则

6.观察结果，不符合预期继续从 0 分析

如果原语句中没有 distinct 不需要去重，我们就可以直接使用 union all 了，因为使用 union 需要去重的动作，会影响 SQL 性能。

但我们在前面的分析中漏了一个细节，先排序再 join 和先 join 再排序理论上开销是一样的，为何提升这么多是因为有一个 limit！大致执行过程是：mysql 先按索引排序得到前 10 条记录，然后再去 join 过滤，当发现不够 10 条的时候，再次去 10 条，再次 join，这显然在内层 join 过滤的数据非常多的时候，将是灾难的，极端情况，内层一条数据都找不到，mysql 还傻乎乎的每次取 10 条，几乎遍历了这个数据表

避免使用 SELECT \*这种方式进行查询，应该只返回需要的列。

当发现查询需要扫描大量的数据行但只返回少数的行，那么可以考虑使用覆盖索引，即把所有需要用到的列都放到索引中。这样存储引擎无须回表获取对应行就可以返回结果了。

降低一条语句一次性执行一个大的删除操作，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但重要的查询

优化关联查询，要确保 ON 或者 USING 子句中的列上有索引，并且在建立索引时需要考虑到关联的顺序。通常来说，只需要在关联顺序中的第二个表的相应列上创建索引。

优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：

SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;

如果这张表非常大，那么这个查询最好改成下面的样子：

SELECT film.film_id,film.description

FROM film INNER JOIN (

    SELECT film_id FROM film ORDER BY title LIMIT 50,5

) AS tmp USING(film_id);
